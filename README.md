# ring_buffer
 `RingBuf` 类实现了一个支持多生产者、多消费者的无锁环形缓冲区，并支持动态扩容。下面是对主要功能的说明：

### 1. 构造函数
构造函数 `RingBuf(uint32_t capacity)` 用于初始化环形缓冲区。它设置了初始容量（不小于16且不超过1024），并分配了相应大小的内存空间。同时，初始化了生产者和消费者的头尾指针，以及容量门限值等其他关键变量。

### 2. Push 函数
`int Push(const T *data, uint32_t size)` 函数用于将数据推入环形缓冲区。

- 如果当前缓冲区正在扩容，调用线程将等待扩容完成。
- 检查缓冲区是否接近满载，如果接近满载则尝试扩容。
- 在确保有足够空间后，计算新的生产者头指针，并将数据写入缓冲区。
- 如果扩容失败或数据写入有问题，返回相应的错误码。

### 3. Pop 函数
`int Pop(T *data, uint32_t size)` 函数用于从环形缓冲区中取出数据。

- 如果缓冲区正在扩容，调用线程将等待扩容完成。
- 如果缓冲区为空，函数将阻塞等待数据到来，或超时返回。
- 读取数据后，更新消费者的头尾指针，并减少缓冲区的大小计数。

### 4. Expand 函数
`int Expand()` 是一个私有函数，用于扩展缓冲区的容量。当缓冲区容量不足时，会调用此函数进行扩容。

- 扩容过程中，确保只有一个线程在进行扩容操作，其他线程等待扩容完成。
- 扩容完成后，更新缓冲区的相关指针，并将新数据复制到扩展后的缓冲区中。

### 5. rearrange_circular_array 函数
`int rearrange_circular_array` 用于在扩容或操作过程中重新排列环形数组中的元素。它将旧数组中的数据复制到新数组中，并处理可能出现的数据分段问题。

### 6. Semaphore 类
`Semaphore` 类提供了一种简单的信号量机制，用于在线程之间协调扩容操作。当扩容开始时，所有其他线程将阻塞在信号量上，直到扩容完成。

### 代码的主要特点：
- **无锁设计**：采用原子操作和比较交换（CAS）机制，实现了无锁的多生产者、多消费者操作。
- **动态扩容**：缓冲区支持动态扩展，避免了在容量不足时丢失数据或产生错误。
- **线程安全**：通过信号量和原子操作，确保了线程之间的互斥访问，避免了竞态条件。
